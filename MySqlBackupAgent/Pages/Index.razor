@page "/"
@using MySqlBackupAgent.Services
@using System.Reactive.Linq
@using System.Threading
@using MySqlBackupAgent.Models
@inject BackupTargetService BackupTargets

<h3>MySQL Backup Utility</h3>
This is a static service, all configuration is performed through the 'appsettings.json' file.

<table class="table">
    <thead class="thead-dark">
    <tr>
        <th scope="col" class="text-nowrap">Database</th>
        <th scope="col" class="text-nowrap">Status</th>
        <th scope="col" class="w-100">Progress/Message</th>
    </tr>
    </thead>
    <tbody>
    
    @foreach (var target in _targets.Values)
    {
        <tr>
            <td class="text-nowrap">
                <a href="backup/@target.Key">@target.Name</a>
            </td>
            
            <!-- Status Column -->
            <td class="text-nowrap">@target.StatusText</td>
            
            <!-- Progress/Message Column -->
            @if (target.State == TargetState.BackingUp || target.State == TargetState.Compressing)
            {
                <td>
                <BSProgress Value="@((int) target.Progress)" IsStriped="true" IsAnimated="true"/>
                </td>
            }
            else if (!string.IsNullOrEmpty(target.InfoMessage))
            {
                <td>@target.InfoMessage</td>
            }
            else
            {
                <td></td>
            }
        </tr>
        
    }
    </tbody>
</table>



@code {
    private Dictionary<string, DbTargetView> _targets;

    protected override void OnInitialized()
    {
        // Extract and check the current synchronization context
        var context = SynchronizationContext.Current;
        if (context == null)
        {
            throw new NullReferenceException("There appears to be no current SynchronizationContext");
        }
        
        // Initialize the target collection
        _targets = new Dictionary<string, DbTargetView>();
        
        // Load the target representation objects
        foreach (var pair in BackupTargets.Targets)
        {
            var target = pair.Value.ToRepr();
            _targets[pair.Key] = target;

            // Update for progress bar
            pair.Value.Progress //.Throttle(TimeSpan.FromSeconds(0.5))
                .ObserveOn(context)
                .Subscribe(d =>
                {
                    _targets[pair.Key].Progress = d;
                    StateHasChanged();
                });

            // Update for overall state
            pair.Value.StateChange.ObserveOn(context)
                .Subscribe(s =>
                {
                    _targets[pair.Key].State = s;
                    StateHasChanged();
                });
            
            // Update for next scheduled time 
            pair.Value.ScheduledChange.ObserveOn(context)
                .Subscribe(t =>
                {
                    _targets[pair.Key].NextTime = t;
                    StateHasChanged();
                });

            pair.Value.InfoMessages.ObserveOn(context)
                .Subscribe(s =>
                {
                    _targets[pair.Key].InfoMessage = s;
                    StateHasChanged();
                });
        }
        
        // Update display every second for timer
        Observable.Interval(TimeSpan.FromSeconds(1))
            .ObserveOn(context)
            .Subscribe(l => StateHasChanged());
    }

}
